#!/usr/bin/env node
/**
 * generate-locale-template.mjs
 *
 * Usage:
 *   node packages/locale/script/generate-locale-template.mjs > locale-template.json
 *
 * Description:
 *   This script reads doc.json (generated by JSDoc) to extract all documented user-facing
 *   function names and their synonyms in Strudel, and outputs a JSON object with each name
 *   as a key and an empty string as the value. The output is suitable as a template for
 *   creating new locale translation files.
 *
 *   Redirect the output to a file to create a template for translators, e.g.:
 *     node packages/locale/script/generate-locale-template.mjs > fr.json
 */
import { readFile } from 'node:fs/promises';
import { dirname, resolve } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const docPath = resolve(__dirname, '../../../doc.json');

async function getDocJSON() {
  try {
    return JSON.parse(await readFile(docPath, 'utf8'));
  } catch (err) {
    if (err.code === 'ENOENT') {
      console.error(`\n[ERROR] doc.json not found at ${docPath}\n` +
        'You need to generate it first by running:\n\n    pnpm jsdoc-json\n\n' +
        'This will create doc.json in the project root, which is required for this script.');
      process.exit(1);
    } else {
      throw err;
    }
  }
}

async function getUserFacingNames() {
  const docJson = await getDocJSON();
  if (!docJson || !Array.isArray(docJson.docs)) {
    console.error('[ERROR] doc.json is missing a valid "docs" array. Please regenerate it with pnpm jsdoc-json.');
    process.exit(1);
  }
  const names = new Set();
  for (const doc of docJson.docs) {
    if (!doc || typeof doc !== 'object' || typeof doc.name !== 'string' || !doc.name.trim()) continue;
    names.add(doc.name);
    if (Array.isArray(doc.tags)) {
      for (const tag of doc.tags) {
        if (tag && tag.title === 'synonyms' && typeof tag.value === 'string') {
          for (const synonym of tag.value.split(/,\s*/)) {
            if (synonym && synonym.trim()) names.add(synonym.trim());
          }
        }
      }
    }
  }
  return Array.from(names).sort();
}

const methods = await getUserFacingNames();
const template = {};
for (const name of methods) {
  template[name] = '';
}

console.log(JSON.stringify(template, null, 2)); 